/* Execution PLAN
	- It is the Roadmap generated by database on How it will execute query step by step.
    - E.g Query: 
				Select ...
				FROM ...
				JOIN ...
		- Execution Plan for above Qurry is First think How to scan data from table by full table scan or using index 
		  then think about join (is it hash join or loop join) and then select Query
		- DB Engine Might Save Execution Plan in cache for similar queries in future so that it doesn't require to rebuild
	- IN SQL/Server
    We Have 3 options in the Query Toolbar
		1. Display Estimated Execution Plan: Predict Execution plan without actually running the query.
        2. Actual Execution Plan: Shows the execution plan as it occurred after running the query.
        3. Live Execcution Plan: Shows Real time execution flow as the query runs.
	- In MY SQL
    MySQL does not have a built-in “Live Execution Plan” like SQL Server.
	Instead, MySQL mainly offers two ways:
		1. EXPLAIN (or EXPLAIN EXTENDED)
			Used before a SELECT, UPDATE, INSERT, or DELETE query.
			Shows the estimated execution plan (how MySQL plans to execute the query: table scans, indexes, joins, etc.).
			Example:
				EXPLAIN SELECT name, score FROM t1 WHERE country = 'India';
			In MySQL Workbench, you can also see a visual EXPLAIN plan.
		2. SHOW PROFILE / Performance Schema (runtime details)
			You can enable profiling and see what actually happened when the query ran (like an Actual Execution Plan).
			Example:
				SET profiling = 1;
				SELECT name FROM t1 WHERE score > 90;
				SHOW PROFILES;
				SHOW PROFILE FOR QUERY 1;
			This shows execution steps, duration, and resource usage.
		3. Performance Schema & EXPLAIN ANALYZE (MySQL 8.0+):
			Starting with MySQL 8.0.18, there is EXPLAIN ANALYZE.
			It runs the query and shows the actual execution plan with timing details (closest to SQL Server’s Actual Execution Plan).
			Example:
				EXPLAIN ANALYZE SELECT name FROM t1 WHERE branch = 'Computer Science';
	
    --> TIPS: 
		1. After Creating Index, Check the Execution Plan that DB using index or not for Query.
	
    INDEX Seek: A Targeted Search within an Index Retrieving Only Specific Rows.
    Type of Scan:
		1. Table Scan: Reads Every Row in a Table.
        2. Index Scan: Reads all entries in an index to find results.
		3. Index Seek: Quickly Locate Specific Rows in an Index.
	
    JOIN ALGORITHMS:
		1. Nested Loops: Compare tables row by row; best for small tables
        2. Hash Match: Matches rows using a hash table; best for large tables.
        3. Merge Join: Merge Two Sorted Tables; efficent when both are sorted.
        
	- Why Execution Plan:
		1. Understand How SQL Execute our Query.
        2. how Many Resources our query consume
        3. Check if new indexes are used or not
        4. Testing and Experimenting Indexes.
	
    -- What Are SQL HINTS
		This is the Commands that we add to Query to force the DB to run it in a specific way for better performance.
        -- TIPS:
			1. Test Hints in ALL Projects Environments (DEV, PROD) as performance may vary.
            2. Hints Are Quick Fixes. (Not Solution we need to find Cause and Fix it).
        
*/

Explain Select * from t1;
Select * from t1 order by email;
create Unique index idx_email_t1 on t1 (email ASC);
-- Change in Execcution Plan
Select * from t1 where email='alice.johnson@example.com' order by name;
Select * from t1 where name='alice' order by name;
Explain Select * from t1 where email='alice.johnson@example.com';

Create Database temp;
use temp;
Create table t1 (
	name varchar(50),
    email varchar(250),
	score int,
    branch varchar(50),
    country varchar(50)
);
INSERT INTO t1 (name, email, score, branch, country) VALUES
('Alice Johnson', 'alice.johnson@example.com', 85, 'Computer Science', 'USA'),
('Ravi Kumar', 'ravi.kumar@example.in', 92, 'Electronics', 'India'),
('Maria Lopez', 'maria.lopez@example.es', 78, 'Mechanical', 'Spain'),
('Chen Wei', 'chen.wei@example.cn', 88, 'Civil', 'China'),
('Fatima Ali', 'fatima.ali@example.ae', 95, 'Information Technology', 'UAE'),
('John Smith', 'john.smith@example.co.uk', 81, 'Electrical', 'UK'),
('Sofia Rossi', 'sofia.rossi@example.it', 90, 'Biotechnology', 'Italy');

-- HINTs
use salesdb;
-- It's Using Nested Loops for Join
select o.sales, c.Country from orders o LEFT JOIN customers c on o.customerid = c.customerid;
-- IN SQL SERVER
-- select o.sales, c.Country from orders o LEFT JOIN customers c on o.customerid = c.customerid Option (HASH JOIN);
CREATE INDEX FK_CUSTOMERID_ORDERS on orders (customerid ASC);
-- IN MYSQL (It will tell MysQL to use Hash JOIN if Possible
select /*+ HASH_JOIN(o, c) */ o.sales, c.Country from orders o LEFT JOIN customers c on o.customerid = c.customerid;


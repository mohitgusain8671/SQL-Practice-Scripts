# Advanced SQL Theory

This document covers the fundamental architecture of SQL databases and how different types of queries are executed internally.

## SQL Architecture Overview

```
CLIENT --> Query --> SERVER
```

The server contains two main components:

### 1. Database Engine
- The brain of the database
- Executes multiple operations: storing, retrieving, and managing data
- Handles query processing and optimization

### 2. Storage System

#### A. Disk Storage (Long-term Memory)
- **Characteristics:**
  - Permanent data storage
  - Large capacity
  - Slower read/write operations

- **Storage Areas:**
  1. **User Area**: Main database content where actual user data is stored
  2. **Catalog Area**: Metadata storage - blueprint tracking database structure (not user data)
  3. **Temp Area**: Temporary data for current transactions and short-term database tasks

#### B. Cache Storage (Short-term Memory)
- **Characteristics:**
  - Temporary data storage
  - Limited capacity
  - Fast read/write operations

## Query Execution Flow

### Standard Flow (Cache Hit)
```
Client --> Query --> Server --> Database Engine --> Storage --> Cache Storage --> Client
```

### Cache Miss Flow
```
Client --> Query --> Server --> Database Engine --> Storage --> Cache Storage --> Not Found 
--> Database Engine --> Disk Storage --> Query Processing --> Database Engine --> Client
```

## Subquery Execution Patterns

### 1. Subquery in FROM Clause

**Execution Steps:**
1. Client writes query containing main query and subquery
2. Client sends query to server
3. Database Engine executes subquery first
4. Intermediate result stored in cache for faster retrieval
5. Database Engine executes main query using cached subquery result
6. Result sent to client
7. Database Engine cleans intermediate result from cache

### 2. Subquery in SELECT Clause

**Execution Steps:**
1. Client writes query containing main query and subquery
2. Client sends query to server
3. Database Engine executes subquery
4. Subquery result passed directly to main query
5. Database Engine executes main query using subquery result
6. Final result sent to client

### 3. Subquery in WHERE Clause (Comparison Operators)

**Execution Steps:**
1. Client writes query containing main query and subquery
2. Client sends query to server
3. Database Engine executes subquery
4. Subquery result passed to main query for comparison
5. Database Engine executes main query using subquery result
6. Final result sent to client

**Note:** Same execution process applies to logical operators (IN, ALL, ANY)

### 4. Correlated Subquery / EXISTS Correlated Subquery

**Execution Steps:**
1. Client writes query containing main query and correlated subquery
2. Client sends query to server
3. Database processes main query **row by row**
4. For each row, current row data passed to subquery
5. Subquery processes using current row context
6. Subquery result returned to main query for current row
7. If subquery returns result: row included in final result
8. If subquery returns no result: row skipped
9. Process repeats for next row

### 5. Non-Correlated Subquery

**Execution Steps:**
1. Client writes query containing main query and non-correlated subquery
2. Client sends query to server
3. Database processes subquery **once** and stores result in cache
4. Database processes main query using cached intermediate result
5. Final result sent to client
6. Database Engine cleans intermediate result from cache

## Key Differences

| Subquery Type | Execution Frequency | Cache Usage | Performance |
|---------------|-------------------|-------------|-------------|
| **Non-Correlated** | Once | Yes | Better |
| **Correlated** | Per row | No | Slower |

## Performance Implications

- **Non-correlated subqueries** are generally more efficient as they execute once
- **Correlated subqueries** can be slower due to row-by-row processing
- **Cache storage** significantly improves performance for repeated data access
- **FROM clause subqueries** benefit most from caching mechanisms
# Database Indexes - Performance Optimization Guide

## Table of Contents
1. [Introduction to Indexes](#introduction-to-indexes)
2. [Index Types](#index-types)
3. [Clustered vs Non-Clustered Indexes](#clustered-vs-non-clustered-indexes)
4. [Rowstore vs Columnstore Indexes](#rowstore-vs-columnstore-indexes)
5. [Specialized Index Types](#specialized-index-types)
6. [Index Creation Syntax](#index-creation-syntax)
7. [Index Best Practices](#index-best-practices)
8. [Index Management](#index-management)
9. [Performance Considerations](#performance-considerations)

## Introduction to Indexes

An **Index** is a data structure that provides quick access to data, optimizing the speed of your queries. Think of it like an index in a book - it helps you quickly locate specific information without scanning through every page.

### Why Use Indexes?
- **Faster Query Performance**: Dramatically reduce query execution time
- **Efficient Data Retrieval**: Avoid full table scans
- **Improved JOIN Performance**: Speed up table relationships
- **Enhanced Sorting**: Faster ORDER BY operations

### The Trade-off
- **Pros**: Faster SELECT queries, improved WHERE clause performance
- **Cons**: Slower INSERT/UPDATE/DELETE operations, additional storage space

## Index Types

### 1. Based on Structure
- **Clustered Index**: Physically sorts and stores table data
- **Non-Clustered Index**: Separate structure with pointers to data

### 2. Based on Storage
- **Rowstore Index**: Stores data row by row (default)
- **Columnstore Index**: Stores data column by column

### 3. Based on Function
- **Unique Index**: Ensures no duplicate values
- **Filtered Index**: Includes only rows meeting specific conditions

## Clustered vs Non-Clustered Indexes

### Database Storage Fundamentals

**Pages**: The smallest unit of data storage in a database (8KB). Contains data, metadata, or indexes.

**Heap Table**: A table without any clustered index. Fast insertion but slow reads due to full table scans.

### Clustered Index

```
┌─────────────────┐
│   Root Page     │  ← Index Pages (B-Tree structure)
├─────────────────┤
│ Intermediate    │  ← Index Pages (B-Tree structure)
│    Pages        │
├─────────────────┤
│   Leaf Pages    │  ← Data Pages (actual table data)
│  (Data Pages)   │
└─────────────────┘
```

**Characteristics:**
- Physically sorts and stores table rows
- Forms a B-Tree structure with data pages as leaf nodes
- Only **one clustered index per table**
- Primary key creates clustered index by default

### Non-Clustered Index

```
┌─────────────────┐
│   Root Page     │  ← Index Pages
├─────────────────┤
│ Intermediate    │
│    Pages        │
├─────────────────┤
│   Leaf Pages    │  ← Index Pages (contain row addresses)
│ (Index Pages)   │     pointing to → Data Pages
└─────────────────┘
```

**Characteristics:**
- Separate structure with pointers to data rows
- **Multiple non-clustered indexes allowed**
- Leaf pages contain row addresses, not actual data
- Additional storage overhead

### Comparison Table

| Feature | Clustered Index | Non-Clustered Index |
|---------|----------------|-------------------|
| **Physical Storage** | Sorts and stores rows | Separate structure with pointers |
| **Quantity per Table** | One only | Multiple allowed |
| **Read Performance** | Faster | Slower (requires lookup) |
| **Write Performance** | Slower (due to sorting) | Faster |
| **Storage Efficiency** | More efficient | Requires additional storage |
| **Best Use Case** | Primary key, range queries | Foreign keys, search conditions |

## Rowstore vs Columnstore Indexes

### Rowstore Index (Default)

**Data Organization:**
```
Page Structure:
┌─────────────────────────────────────┐
│ Header                              │
├─────────────────────────────────────┤
│ Row 1: [Col1][Col2][Col3][Col4]     │
│ Row 2: [Col1][Col2][Col3][Col4]     │
│ Row 3: [Col1][Col2][Col3][Col4]     │
├─────────────────────────────────────┤
│ Offset Array                        │
└─────────────────────────────────────┘
```

### Columnstore Index

**Data Organization Process:**
1. **Split rows into groups** (row groups)
2. **Create column segments** for each column
3. **Apply data compression** (store unique values with dictionary)
4. **Store in Large Object Pages**

```
Traditional Rowstore:
Row 1: [A1][B1][C1]
Row 2: [A2][B2][C2]
Row 3: [A1][B3][C1]

Columnstore:
Column A: [A1, A2, A1] → Compressed: [A1:2, A2:1]
Column B: [B1, B2, B3] → Compressed: [B1:1, B2:1, B3:1]
Column C: [C1, C2, C1] → Compressed: [C1:2, C2:1]
```

### Comparison Table

| Feature | Rowstore Index | Columnstore Index |
|---------|---------------|------------------|
| **Data Organization** | Row by row | Column by column |
| **Storage Efficiency** | Less efficient | Highly efficient (compression) |
| **Read Performance** | Fast for complete records | Fast for specific columns |
| **Write Performance** | Fast | Slow |
| **I/O Efficiency** | Lower (retrieves all columns) | Higher (retrieves specific columns) |
| **Best for** | OLTP (Transactional) | OLAP (Analytical) |
| **Use Cases** | Banking, e-commerce, order processing | Data warehouses, BI, analytics |

## Specialized Index Types

### 1. Unique Index

Ensures no duplicate values exist in specified columns.

**Benefits:**
- Enforces data integrity
- Slightly improves query performance
- Faster reads, slower writes

### 2. Filtered Index

Includes only rows meeting specified conditions.

**Benefits:**
- Targeted optimization for specific data subsets
- Reduced storage requirements
- Improved performance for filtered queries

**Limitations:**
- Cannot be created on clustered indexes
- Cannot be created on columnstore indexes
- Only available in SQL Server (not MySQL)

## Index Creation Syntax

### SQL Server

```sql
-- Basic Index
CREATE [CLUSTERED | NONCLUSTERED] INDEX index_name 
ON table_name (column1, column2, ...);

-- Unique Index
CREATE UNIQUE [CLUSTERED | NONCLUSTERED] INDEX index_name 
ON table_name (column1, column2, ...);

-- Columnstore Index
CREATE [CLUSTERED | NONCLUSTERED] COLUMNSTORE INDEX index_name 
ON table_name (column1, column2, ...);

-- Filtered Index (SQL Server only)
CREATE NONCLUSTERED INDEX index_name 
ON table_name (column1, column2, ...) 
WHERE condition;
```

### MySQL

```sql
-- Basic Index
CREATE [UNIQUE | FULLTEXT | SPATIAL] INDEX index_name
ON table_name (column1 [ASC | DESC], column2 [ASC | DESC], ...);

-- Index Types:
-- UNIQUE: Ensures values are unique
-- FULLTEXT: Used for full-text search (CHAR, VARCHAR, TEXT only)
-- SPATIAL: Used for spatial data types
-- ASC | DESC: Sort order (MySQL 8.0+)
```

### Examples

```sql
-- Clustered index on primary key
CREATE CLUSTERED INDEX IX_Customer_ID 
ON Customers (CustomerID);

-- Non-clustered index for frequent searches
CREATE NONCLUSTERED INDEX IX_Customer_Country 
ON Customers (Country, LastName);

-- Unique index for email
CREATE UNIQUE INDEX IX_Customer_Email 
ON Customers (Email);

-- Filtered index for active customers (SQL Server)
CREATE NONCLUSTERED INDEX IX_ActiveCustomers 
ON Customers (LastName, FirstName) 
WHERE Status = 'Active';

-- Columnstore for analytics
CREATE NONCLUSTERED COLUMNSTORE INDEX IX_Sales_Analytics 
ON Sales (OrderDate, ProductID, Quantity, Revenue);
```

## Index Best Practices

### 1. Index Column Order Matters

**Critical Rule**: Indexes work only if queries filter starting from the first column in the index and follow its order.

```sql
-- Index: IX_Example (Col1, Col2, Col3)

-- ✅ Index will be used:
SELECT * FROM Table WHERE Col1 = 'value';
SELECT * FROM Table WHERE Col1 = 'value' AND Col2 = 'value';
SELECT * FROM Table WHERE Col1 = 'value' AND Col2 = 'value' AND Col3 = 'value';

-- ❌ Index will NOT be used:
SELECT * FROM Table WHERE Col2 = 'value';
SELECT * FROM Table WHERE Col3 = 'value';
SELECT * FROM Table WHERE Col2 = 'value' AND Col3 = 'value';
```

### 2. When to Use Each Index Type

| Scenario | Recommended Index Type |
|----------|----------------------|
| **Primary Key** | Clustered Index |
| **Foreign Keys** | Non-Clustered Index |
| **Frequent WHERE clauses** | Non-Clustered Index |
| **JOIN conditions** | Non-Clustered Index |
| **Date ranges** | Clustered Index (if primary) |
| **Analytical queries** | Columnstore Index |
| **Large table analytics** | Columnstore Index |
| **Staging tables** | Heap (no index) |
| **Unique constraints** | Unique Index |
| **Subset filtering** | Filtered Index |

### 3. Index Design Guidelines

- **Selectivity**: Index columns with high selectivity (many unique values)
- **Column Order**: Most selective column first
- **Covering Indexes**: Include frequently accessed columns
- **Avoid Over-Indexing**: Too many indexes slow down writes
- **Monitor Usage**: Remove unused indexes

## Index Management

### 1. Monitor Index Usage

```sql
-- SQL Server: Check index usage
SELECT 
    i.name AS IndexName,
    s.user_seeks,
    s.user_scans,
    s.user_lookups,
    s.user_updates
FROM sys.dm_db_index_usage_stats s
JOIN sys.indexes i ON s.object_id = i.object_id AND s.index_id = i.index_id;
```

### 2. Identify Missing Indexes

```sql
-- SQL Server: Find missing indexes
SELECT 
    mid.statement AS TableName,
    migs.avg_total_user_cost * (migs.avg_user_impact / 100.0) * (migs.user_seeks + migs.user_scans) AS improvement_measure,
    'CREATE INDEX IX_' + REPLACE(REPLACE(REPLACE(mid.statement,'[',''),']',''),'.','_') + '_' + 
    REPLACE(REPLACE(mid.equality_columns + ISNULL('_' + mid.inequality_columns, ''), '[', ''), ']', '') +
    ' ON ' + mid.statement + ' (' + ISNULL(mid.equality_columns,'') + 
    CASE WHEN mid.equality_columns IS NOT NULL AND mid.inequality_columns IS NOT NULL THEN ',' ELSE '' END +
    ISNULL(mid.inequality_columns, '') + ')' + 
    ISNULL(' INCLUDE (' + mid.included_columns + ')', '') AS create_index_statement
FROM sys.dm_db_missing_index_groups mig
JOIN sys.dm_db_missing_index_group_stats migs ON migs.group_handle = mig.index_group_handle
JOIN sys.dm_db_missing_index_details mid ON mig.index_handle = mid.index_handle
ORDER BY improvement_measure DESC;
```

### 3. Index Fragmentation Management

**Fragmentation Types:**
- **Internal Fragmentation**: Unused space within pages
- **External Fragmentation**: Pages out of logical order

**Fragmentation Thresholds:**
- **< 10%**: No action needed
- **10-30%**: REORGANIZE (light defragmentation)
- **> 30%**: REBUILD (complete recreation)

```sql
-- Check fragmentation
SELECT 
    i.name AS IndexName,
    ips.avg_fragmentation_in_percent,
    ips.page_count
FROM sys.dm_db_index_physical_stats(DB_ID(), NULL, NULL, NULL, 'DETAILED') ips
JOIN sys.indexes i ON ips.object_id = i.object_id AND ips.index_id = i.index_id
WHERE ips.avg_fragmentation_in_percent > 10;

-- Reorganize index (10-30% fragmentation)
ALTER INDEX IX_IndexName ON TableName REORGANIZE;

-- Rebuild index (>30% fragmentation)
ALTER INDEX IX_IndexName ON TableName REBUILD;
```

### 4. Update Statistics

```sql
-- Update statistics weekly or after large data changes
UPDATE STATISTICS TableName;
UPDATE STATISTICS TableName IndexName;
```

## Performance Considerations

### 1. Index Overhead

- **Storage**: Each index requires additional disk space
- **Memory**: Indexes consume buffer pool memory
- **Maintenance**: Updates require index maintenance

### 2. Query Optimization

- **Covering Indexes**: Include all columns needed by query
- **Index Intersection**: Multiple indexes can be combined
- **Index Hints**: Force specific index usage (use sparingly)

### 3. Monitoring Tools

- **Execution Plans**: Analyze query performance
- **Index Usage Stats**: Track index effectiveness
- **Wait Statistics**: Identify bottlenecks
- **Query Store**: Historical performance data

## Conclusion

Indexes are powerful tools for database performance optimization, but they require careful planning and maintenance. The key is finding the right balance between read performance and write overhead while considering your specific workload patterns.

**Remember:**
- Start with clustered indexes on primary keys
- Add non-clustered indexes for frequently filtered columns
- Use columnstore indexes for analytical workloads
- Monitor and maintain your indexes regularly
- Remove unused indexes to reduce overhead

Proper indexing strategy can transform slow queries into lightning-fast operations, making it one of the most impactful database optimization techniques available.
# SQL Performance Optimization - Best Practices Guide

## Table of Contents

1. [Golden Rules](#golden-rules)
2. [Data Fetching Optimization](#data-fetching-optimization)
3. [Filtering Data Efficiently](#filtering-data-efficiently)
4. [JOIN Performance Optimization](#join-performance-optimization)
5. [Subquery Optimization](#subquery-optimization)
6. [Table Design Best Practices](#table-design-best-practices)
7. [Indexing Strategy](#indexing-strategy)
8. [Advanced Optimization Techniques](#advanced-optimization-techniques)

## Golden Rules

### Rule #1: Always Check the Execution Plan

**The most important rule in SQL optimization**

```sql
-- SQL Server
SET STATISTICS IO ON;
SET STATISTICS TIME ON;

-- View execution plan before running your query
-- Analyze:
-- - Index usage
-- - Table scans vs index seeks
-- - Join algorithms
-- - Estimated vs actual rows
```

### Rule #2: Focus on Readability When Performance is Equal

If two queries perform similarly, choose the more readable and maintainable option.

## Data Fetching Optimization

### 1. Select Only What You Need

```sql
-- ❌ BAD: Fetching unnecessary data
SELECT * FROM customers;

-- ✅ GOOD: Select only required columns
SELECT customerid, firstname, lastname
FROM customers;
```

**Why it matters:**

- Reduces network traffic
- Decreases memory usage
- Improves cache efficiency
- Faster data transfer

### 2. Avoid Unnecessary Operations

```sql
-- ❌ BAD: Unnecessary DISTINCT
SELECT DISTINCT customerid, firstname
FROM customers
WHERE customerid = 1;  -- Already unique

-- ✅ GOOD: Remove unnecessary DISTINCT
SELECT customerid, firstname
FROM customers
WHERE customerid = 1;

-- ❌ BAD: Unnecessary ORDER BY
SELECT COUNT(*) FROM orders;  -- Count doesn't need ordering

-- ✅ GOOD: Remove ORDER BY when not needed
SELECT COUNT(*) FROM orders;
```

### 3. Limit Rows for Exploration

```sql
-- ✅ GOOD: Use LIMIT/TOP for data exploration
SELECT TOP 100 * FROM large_table;  -- SQL Server
SELECT * FROM large_table LIMIT 100;  -- MySQL

-- ✅ GOOD: Use pagination for large result sets
SELECT * FROM orders
ORDER BY orderdate
OFFSET 0 ROWS FETCH NEXT 50 ROWS ONLY;  -- SQL Server

SELECT * FROM orders
ORDER BY orderdate
LIMIT 50 OFFSET 0;  -- MySQL
```

## Filtering Data Efficiently

### 1. Create Indexes on Filter Columns

```sql
-- Create non-clustered indexes on frequently filtered columns
CREATE NONCLUSTERED INDEX IX_Orders_Status
ON orders (orderstatus);

CREATE NONCLUSTERED INDEX IX_Customers_Country
ON customers (country);
```

### 2. Avoid Functions in WHERE Clauses

```sql
-- ❌ BAD: Function prevents index usage
SELECT * FROM orders
WHERE YEAR(orderdate) = 2025;

-- ✅ GOOD: Use range conditions
SELECT * FROM orders
WHERE orderdate >= '2025-01-01'
  AND orderdate < '2026-01-01';

-- ❌ BAD: Function on column
SELECT * FROM customers
WHERE UPPER(lastname) = 'SMITH';

-- ✅ GOOD: Store data in consistent case or use computed columns
SELECT * FROM customers
WHERE lastname = 'Smith';
```

### 3. Avoid Leading Wildcards

```sql
-- ❌ BAD: Leading wildcard prevents index usage
SELECT * FROM customers
WHERE lastname LIKE '%GOLD%';

-- ✅ GOOD: Trailing wildcard can use index
SELECT * FROM customers
WHERE lastname LIKE 'GOLD%';

-- ✅ BETTER: Full-text search for complex patterns
SELECT * FROM customers
WHERE CONTAINS(lastname, 'GOLD');
```

### 4. Use IN Instead of Multiple OR

```sql
-- ❌ BAD: Multiple OR conditions
SELECT * FROM orders
WHERE orderstatus = 'Shipped'
   OR orderstatus = 'Delivered'
   OR orderstatus = 'Processing';

-- ✅ GOOD: Use IN operator
SELECT * FROM orders
WHERE orderstatus IN ('Shipped', 'Delivered', 'Processing');
```

## JOIN Performance Optimization

### Performance Order of JOINs

```
INNER JOIN > LEFT/RIGHT JOIN > FULL OUTER JOIN
   (Best)      (Moderate)         (Slowest)
```

### 1. Use Explicit JOINs (ANSI-JOIN)

```sql
-- ❌ BAD: Implicit JOIN (Non-ANSI)
SELECT o.orderid, c.firstname
FROM customers c, orders o
WHERE c.customerid = o.customerid;

-- ✅ GOOD: Explicit JOIN (ANSI-JOIN)
SELECT o.orderid, c.firstname
FROM customers c
INNER JOIN orders o ON c.customerid = o.customerid;
```

**Benefits of explicit JOINs:**

- Clearer intent and readability
- Better query optimization
- Easier to maintain and debug
- Prevents accidental Cartesian products

### 2. Ensure JOIN Columns are Indexed

```sql
-- Create indexes on JOIN columns
CREATE NONCLUSTERED INDEX IX_Orders_CustomerID
ON orders (customerid);

CREATE NONCLUSTERED INDEX IX_Orders_ProductID
ON orders (productid);
```

### 3. Filter Strategies

#### A. After JOIN (WHERE) - Small & Medium Tables

```sql
SELECT o.orderid, c.firstname
FROM customers c
INNER JOIN orders o ON c.customerid = o.customerid
WHERE o.orderstatus = 'Delivered';
```

#### B. During JOIN (ON) - Good for Readability

```sql
SELECT o.orderid, c.firstname
FROM customers c
INNER JOIN orders o ON c.customerid = o.customerid
                   AND o.orderstatus = 'Delivered';
```

#### C. Before JOIN (Subquery/CTE) - Large Tables

```sql
-- Using subquery
SELECT o.orderid, c.firstname
FROM customers c
INNER JOIN (
    SELECT orderid, customerid
    FROM orders
    WHERE orderstatus = 'Delivered'
) o ON c.customerid = o.customerid;

-- Using CTE
WITH DeliveredOrders AS (
    SELECT orderid, customerid
    FROM orders
    WHERE orderstatus = 'Delivered'
)
SELECT o.orderid, c.firstname
FROM customers c
INNER JOIN DeliveredOrders o ON c.customerid = o.customerid;
```

### 4. Aggregate Before Joining

#### A. Grouping After JOIN - Small Tables (Easy Readability)

```sql
SELECT c.customerid, c.firstname, COUNT(o.orderid) as OrderCount
FROM customers c
INNER JOIN orders o ON c.customerid = o.customerid
GROUP BY c.customerid, c.firstname;
```

#### B. Pre-Aggregated Query - Best Performance for Large Tables

```sql
SELECT c.customerid, c.firstname, o.OrderCount
FROM customers c
INNER JOIN (
    SELECT customerid, COUNT(orderid) as OrderCount
    FROM orders
    GROUP BY customerid
) o ON c.customerid = o.customerid;
```

#### C. Correlated Subquery - Inefficient (Avoid)

```sql
-- ❌ BAD: Executes subquery for every row
SELECT c.customerid, c.firstname,
       (SELECT COUNT(orderid)
        FROM orders o
        WHERE o.customerid = c.customerid) as OrderCount
FROM customers c;
```

### 5. Use UNION Instead of OR in JOINs

```sql
-- ❌ BAD: OR in JOIN condition
SELECT o.orderid, c.firstname
FROM customers c
INNER JOIN orders o ON c.customerid = o.customerid
                    OR c.customerid = o.salespersonid;

-- ✅ GOOD: Use UNION
SELECT o.orderid, c.firstname
FROM customers c
INNER JOIN orders o ON c.customerid = o.customerid
UNION
SELECT o.orderid, c.firstname
FROM customers c
INNER JOIN orders o ON c.customerid = o.salespersonid;
```

### 6. Additional JOIN Optimizations

- **Check for nested loops** and use SQL hints when necessary (HASH JOIN, MERGE JOIN)
- **Use UNION ALL** instead of UNION when duplicates are acceptable
- **Use UNION ALL + DISTINCT** instead of UNION when you need to remove duplicates but want better performance

```sql
-- Better performance than UNION
SELECT column1, column2 FROM table1
UNION ALL
SELECT column1, column2 FROM table2;

-- If you need distinct results
SELECT DISTINCT column1, column2 FROM (
    SELECT column1, column2 FROM table1
    UNION ALL
    SELECT column1, column2 FROM table2
) combined;
```

### 7. Use Columnstore Indexes for Large Table Aggregations

```sql
-- Create columnstore index for analytical queries
CREATE NONCLUSTERED COLUMNSTORE INDEX IX_Orders_Analytics
ON orders (orderdate, productid, quantity, sales);
```

## Subquery Optimization

### Performance Comparison: JOIN vs EXISTS vs IN

```
Performance Order:
EXISTS ≥ JOIN > IN
(Best)  (Good) (Worst)
```

### 1. Use EXISTS for Large Tables

```sql
-- ✅ BEST: EXISTS stops at first match
SELECT c.customerid, c.firstname
FROM customers c
WHERE EXISTS (
    SELECT 1 FROM orders o
    WHERE o.customerid = c.customerid
);

-- ✅ GOOD: JOIN (if performance equals EXISTS)
SELECT DISTINCT c.customerid, c.firstname
FROM customers c
INNER JOIN orders o ON c.customerid = o.customerid;

-- ❌ AVOID: IN with large datasets
SELECT c.customerid, c.firstname
FROM customers c
WHERE c.customerid IN (
    SELECT customerid FROM orders
);
```

### 2. Avoid Redundant Logic

```sql
-- ❌ BAD: Redundant conditions
SELECT * FROM orders
WHERE orderdate >= '2025-01-01'
  AND orderdate >= '2025-01-01'  -- Redundant
  AND orderstatus = 'Delivered';

-- ✅ GOOD: Clean, non-redundant logic
SELECT * FROM orders
WHERE orderdate >= '2025-01-01'
  AND orderstatus = 'Delivered';
```

## Table Design Best Practices

### 1. Choose Appropriate Data Types

```sql
-- ❌ BAD: Unnecessarily large data types
CREATE TABLE customers (
    customerid INT,
    firstname VARCHAR(MAX),  -- Too large
    lastname TEXT,           -- Avoid TEXT when possible
    age BIGINT              -- INT is sufficient for age
);

-- ✅ GOOD: Appropriate data types
CREATE TABLE customers (
    customerid INT,
    firstname VARCHAR(50),   -- Reasonable size
    lastname VARCHAR(100),   -- Use VARCHAR instead of TEXT
    age TINYINT             -- Sufficient for age (0-255)
);
```

### 2. Use Constraints Effectively

```sql
-- ✅ GOOD: Proper constraints
CREATE TABLE customers (
    customerid INT NOT NULL PRIMARY KEY,  -- Clustered primary key
    firstname VARCHAR(50) NOT NULL,       -- NOT NULL where applicable
    lastname VARCHAR(50) NOT NULL,
    email VARCHAR(100) UNIQUE NOT NULL,   -- Unique constraint
    age TINYINT CHECK (age >= 0 AND age <= 150),  -- Check constraint
    created_date DATETIME2 NOT NULL DEFAULT GETDATE()
);
```

### 3. Primary and Foreign Key Strategy

```sql
-- ✅ Ensure all tables have a clustered primary key
CREATE TABLE orders (
    orderid INT IDENTITY(1,1) PRIMARY KEY,  -- Auto-incrementing PK
    customerid INT NOT NULL,
    productid INT NOT NULL,
    orderdate DATE NOT NULL,

    -- Create non-clustered indexes for foreign keys
    INDEX IX_Orders_CustomerID (customerid),
    INDEX IX_Orders_ProductID (productid),

    -- Foreign key constraints
    FOREIGN KEY (customerid) REFERENCES customers(customerid),
    FOREIGN KEY (productid) REFERENCES products(productid)
);
```

## Indexing Strategy

### 1. Avoid Over-Indexing

```sql
-- ❌ BAD: Too many indexes on same table
CREATE INDEX IX1 ON orders (customerid);
CREATE INDEX IX2 ON orders (customerid, orderdate);
CREATE INDEX IX3 ON orders (customerid, productid);
CREATE INDEX IX4 ON orders (customerid, orderstatus);
-- This slows down INSERT/UPDATE/DELETE operations

-- ✅ GOOD: Strategic indexing
CREATE INDEX IX_Orders_Customer_Date ON orders (customerid, orderdate);
CREATE INDEX IX_Orders_Status ON orders (orderstatus);
-- Covers most query patterns efficiently
```

### 2. Index Maintenance

```sql
-- Drop unused indexes
DROP INDEX IX_UnusedIndex ON table_name;

-- Update statistics weekly
UPDATE STATISTICS table_name;
UPDATE STATISTICS table_name index_name;

-- Reorganize fragmented indexes (10-30% fragmentation)
ALTER INDEX IX_IndexName ON table_name REORGANIZE;

-- Rebuild heavily fragmented indexes (>30% fragmentation)
ALTER INDEX IX_IndexName ON table_name REBUILD;
```

### 3. Monitor Index Usage

```sql
-- SQL Server: Check index usage statistics
SELECT
    OBJECT_NAME(s.object_id) AS TableName,
    i.name AS IndexName,
    s.user_seeks,
    s.user_scans,
    s.user_lookups,
    s.user_updates,
    CASE
        WHEN s.user_seeks + s.user_scans + s.user_lookups = 0
        THEN 'Consider dropping'
        ELSE 'Keep'
    END AS Recommendation
FROM sys.dm_db_index_usage_stats s
INNER JOIN sys.indexes i ON s.object_id = i.object_id
                        AND s.index_id = i.index_id
WHERE OBJECTPROPERTY(s.object_id, 'IsUserTable') = 1;
```

## Advanced Optimization Techniques

### 1. Table Partitioning

For very large tables, consider partitioning:

```sql
-- Example: Partition by date range
CREATE PARTITION FUNCTION pf_OrderDate (DATE)
AS RANGE RIGHT FOR VALUES
('2024-01-01', '2024-04-01', '2024-07-01', '2024-10-01', '2025-01-01');

CREATE PARTITION SCHEME ps_OrderDate
AS PARTITION pf_OrderDate
TO (fg1, fg2, fg3, fg4, fg5, fg6);

CREATE TABLE orders_partitioned (
    orderid INT IDENTITY(1,1),
    orderdate DATE NOT NULL,
    customerid INT NOT NULL,
    -- other columns
    PRIMARY KEY (orderid, orderdate)  -- Include partition key
) ON ps_OrderDate(orderdate);
```

### 2. Columnstore Indexes for Analytics

```sql
-- For large analytical queries
CREATE NONCLUSTERED COLUMNSTORE INDEX IX_Orders_Analytics
ON orders (orderdate, customerid, productid, quantity, sales);

-- Query benefits from columnstore
SELECT
    YEAR(orderdate) as OrderYear,
    SUM(sales) as TotalSales,
    COUNT(*) as OrderCount
FROM orders
WHERE orderdate >= '2024-01-01'
GROUP BY YEAR(orderdate);
```

### 3. Query Hints (Use Sparingly)

```sql
-- Force specific join algorithm when optimizer chooses poorly
SELECT /*+ USE_HASH(o, c) */
    o.orderid, c.firstname
FROM orders o
INNER JOIN customers c ON o.customerid = c.customerid;

-- Force index usage
SELECT * FROM orders WITH (INDEX(IX_Orders_Status))
WHERE orderstatus = 'Delivered';
```

## Performance Monitoring Checklist

### Daily Tasks

- [ ] Monitor slow query log
- [ ] Check for blocking queries
- [ ] Review error logs

### Weekly Tasks

- [ ] Update statistics on high-activity tables
- [ ] Check index fragmentation
- [ ] Reorganize/rebuild fragmented indexes
- [ ] Review query execution plans

### Monthly Tasks

- [ ] Analyze index usage statistics
- [ ] Remove unused indexes
- [ ] Review and optimize top resource-consuming queries
- [ ] Check table growth and consider partitioning

### Best Practices Summary

1. **Always check execution plans** before and after optimization
2. **Select only needed columns** and limit rows when exploring
3. **Create indexes strategically** on frequently filtered and joined columns
4. **Avoid functions in WHERE clauses** that prevent index usage
5. **Use explicit JOINs** and ensure JOIN columns are indexed
6. **Filter data early** in the query process
7. **Choose appropriate data types** and use NOT NULL constraints
8. **Monitor and maintain indexes** regularly
9. **Consider partitioning** for very large tables
10. **Use columnstore indexes** for analytical workloads

Remember: **Premature optimization is the root of all evil**. Profile first, then optimize based on actual performance bottlenecks, not assumptions.
